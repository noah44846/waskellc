data Bool = True | False;

and :: Bool -> Bool -> Bool;
and True y = y;
and False _ = False;

or :: Bool -> Bool -> Bool;
or True _ = True;
or False y = y;

if' :: Bool -> a -> a -> a;
if' True x _ = x;
if' False _ y = y;

boolToInt :: Bool -> Int;
boolToInt True = 100;
boolToInt False = -100;

intToBool :: Int -> Bool;
intToBool 0 = False;
intToBool _ = True;

boolMain :: Int;
-- -100 + 100 + -100 = -100
boolMain = boolToInt (if' (intToBool 0) True False) + boolToInt (if' (intToBool 1) True False) + boolToInt (and (or True False) (and False True));

data List a = Nil | Cons a (List a);

map :: (a -> b) -> List a -> List b;
map _ Nil = Nil;
map f (Cons x xs) = Cons (f x) (map f xs);

fold :: (b -> a -> b) -> b -> List a -> b;
fold _ z Nil = z;
fold f z (Cons x xs) = f x (fold f z xs);

repeat :: a -> List a;
repeat x = Cons x (repeat x);

take :: Int -> List a -> List a;
take 0 _ = Nil;
take n Nil = Nil;
take n (Cons x xs) = Cons x (take (n - 1) xs);

concat :: List a -> List a -> List a;
concat Nil ys = ys;
concat (Cons x xs) ys = Cons x (concat xs ys);

listMain :: Int;
listMain = fold (+) 0 (take 10 (map ((*) 2) (repeat 1)));

data Maybe a = Just a | Nothing;

maybe :: b -> (a -> b) -> Maybe a -> b;
maybe z _ Nothing = z;
maybe _ f (Just x) = f x;

maybeMain :: Int;
-- (2 + 1) + 0 = 3
maybeMain = (maybe 0 ((+) 2) (Just 1)) + (maybe 0 ((+) 1) Nothing);

data Ratio = Ratio Int Int;

ratioMul :: Ratio -> Ratio -> Ratio;
ratioMul (Ratio a b) (Ratio c d) = Ratio (a * c) (b * d);

ratioAdd :: Ratio -> Ratio -> Ratio;
ratioAdd (Ratio a b) (Ratio c d) = Ratio (a * d + b * c) (b * d);

eval :: Ratio -> Int;
eval (Ratio a b) = a / b;

ratioMain :: Int;
-- (1/2 + 1/3) * 12/2 = 5/6 * 6 = 5
ratioMain = eval (ratioMul (ratioAdd (Ratio 1 2) (Ratio 1 3)) (Ratio 12 2));

data Tree a = Empty | Node (Tree a) a (Tree a);

--foreign export wasm empty :: Tree a;
--empty = Empty;

--foreign export wasm node :: Tree a -> a -> Tree a -> Tree a;
--node = Node;

foreign export wasm leaf :: a -> Tree a;
leaf x = Node Empty x Empty;

treeMap :: (a -> b) -> Tree a -> Tree b;
treeMap f Empty = Empty;
treeMap f (Node l x r) = Node (treeMap f l) (f x) (treeMap f r);

treeFold :: (b -> a -> b -> b) -> b -> Tree a -> b;
treeFold _ z Empty = z;
treeFold f z (Node l x r) = f (treeFold f z l) x (treeFold f z r);

flattenHelper :: List a -> a -> List a -> List a;
flattenHelper l x r = concat l (Cons x r);

foreign export wasm flattenDfs :: Tree a -> List a;
flattenDfs = treeFold flattenHelper Nil;

add3 :: Int -> Int -> Int -> Int;
add3 x y z = x + y + z;

exampleTree :: Tree Int;
exampleTree = Node (Node (leaf 1) 2 (leaf 3)) 4 (leaf 5);

foreign export wasm exampleTreeFlattened :: List Int;
exampleTreeFlattened = flattenDfs (treeMap ((*) 3) exampleTree);

treeMain :: Int;
-- 2*1 + 2*2 + 2*3 + 2*4 + 2*5 = 30
treeMain = treeFold add3 0 (treeMap ((*) 2) exampleTree);

main :: Int;
-- -100 + 20 + 3 + 5 + 30 = -42
-- -100 + 20 + 3 + 5 = -72
main = boolMain + listMain + maybeMain + ratioMain -- + treeMain;
